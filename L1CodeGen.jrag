aspect L1CodeGen {
	inh lazy int ClassInstanceExpr.localNum();

	eq FieldDeclaration.getInit().localNum() {
		int localNum = 1;
		for (Iterator iter = hostType().constructors().iterator(); iter.hasNext(); ) {
			ConstructorDecl c = (ConstructorDecl)iter.next();
			int num = c.getNumParameter() == 0 ? c.localNumOfFirstParameter() :
			c.getParameter(c.getNumParameter() - 1).localNum() + c.getParameter(c.getNumParameter() - 1).type().variableSize();
			if (num > localNum)
				localNum = num;
		}
		return localNum;
	}

	void OwnerOfExpr.emitOperation(CodeGeneration gen) {
		String classname = "JavaDBRuntime";
		String      desc = "()LJavaDBRuntime;";
		String      name = "getInstance";
		int index = gen.constantPool().addMethodref(classname, name, desc);
		gen.emit(Bytecode.INVOKESTATIC, 1).add2(index);

		getOperand().createBCode(gen);

		desc = "(Ljava/lang/Object;)Ljava/lang/Object;";
		name = "getParent";
		index = gen.constantPool().addMethodref(classname, name, desc);
		gen.emit(Bytecode.INVOKEVIRTUAL, -1).add2(index);

		gen.emitCheckCast(type());
	}

	refine CreateBCode public void ClassInstanceExpr.createBCode(CodeGeneration gen) {
		CreateBCode.ClassInstanceExpr.createBCode(gen);

		//if this is the type is ownedby, then we do following
		if (!type().getOwnerType().isUnknown()) {
			gen.emitDup();

			int num = localNum();
			gen.emitStoreReference(num); //store to local

			String classname = "JavaDBRuntime";
			String      desc = "()LJavaDBRuntime;";
			String      name = "getInstance";
			int index = gen.constantPool().addMethodref(classname, name, desc);
			gen.emit(Bytecode.INVOKESTATIC, 1).add2(index);

			gen.emitLoadReference(num); //push the new object to stack
			gen.emitLoadReference(0); //push this to stack

			desc = "(Ljava/lang/Object;Ljava/lang/Object;)V";
			name = "putParent";
			index = gen.constantPool().addMethodref(classname, name, desc);
			gen.emit(Bytecode.INVOKEVIRTUAL, -2).add2(index);
		}
	}
}