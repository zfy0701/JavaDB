aspect L1CodeGen {
	//TODO replace the runtime with static function call

	void OwnerOfExpr.emitOperation(CodeGeneration gen) {
		getOperand().createBCode(gen);

		String classname = "javadb.JavaDBRuntime";
		String      desc = "(Ljava/lang/Object;)Ljava/lang/Object;";
		String      name = "getParent";
		int index = gen.constantPool().addMethodref(classname, name, desc);
		gen.emit(Bytecode.INVOKESTATIC, 1).add2(index);

		gen.emitCheckCast(type());
	}

	refine CreateBCode public void ClassInstanceExpr.createBCode(CodeGeneration gen) {
		refined(gen);

		//L1: if this is the type is ownedby, then we do following
		if (!type().getOwnerType().isUnknown()) {
			gen.emitDup();

			gen.emitLoadReference(0); //push this to stack
			
			String classname = "javadb.JavaDBRuntime";
			String desc = "(Ljava/lang/Object;Ljava/lang/Object;)V";
			String name = "putParent";
			int index = gen.constantPool().addMethodref(classname, name, desc);
			gen.emit(Bytecode.INVOKESTATIC, -2).add2(index);
		}
	}


	refine GenericsCodegen public void VarAccess.emitStore(CodeGeneration gen) {
		if (isParField()) {
			//we already have the object and the target value in the stack

			//now box the value if it is primitive, only isPrimitive seems have bugs
			if (!type().isReferenceType() && type().isPrimitive())
				type().boxed().emitBoxingOperation(gen);

			gen.emitLoadReference(0); //push this to stack

			StringLiteral.push(gen, name()); //load field name string

			String classname = "javadb.JavaDBRuntime";
			String      desc = "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/String;)V";
			String      name = "setFieldValue";
			int index = gen.constantPool().addMethodref(classname, name, desc);
			gen.emit(Bytecode.INVOKESTATIC, 1).add2(index);

		} else
			refined(gen);
	}


	refine GenericsCodegen public void VarAccess.createBCode(CodeGeneration gen) {
		if (isParField()) {
			gen.emitLoadReference(0); //push this to stack
			createLoadQualifier(gen); //push the object who have the field to stack

			//load field name string
			StringLiteral.push(gen, name());

			String classname = "javadb.JavaDBRuntime";
			String      desc = "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;";
			String      name = "getFieldValue";
			int index = gen.constantPool().addMethodref(classname, name, desc);
			gen.emit(Bytecode.INVOKESTATIC, 1).add2(index);
			
			//now box the value if it is primitive, only isPrimitive seems have bugs
			if (!type().isReferenceType() && type().isPrimitive()) {
				TypeDecl boxTy = type().boxed();
				gen.emitCheckCast(boxTy);
				boxTy.emitUnboxingOperation(gen);
			} else
				gen.emitCheckCast(type());

		} else
			refined(gen);
	}

	public void  ParFieldClassInstanceExpr.createBCode(CodeGeneration gen) {
		super.createBCode(gen);

		//iterate and register field
		List<FieldVariable> fieldPars = type().getFieldPars();
		List<ParFieldAccess> fieldArgs = this.getFieldArguments();

		String classname = "javadb.JavaDBRuntime";
		String      desc = "(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V";
		String      name = "registerField";
		int index = gen.constantPool().addMethodref(classname, name, desc);

		for (int i = 0; i < fieldArgs.getNumChild(); i++) {
			FieldVariable fv = fieldPars.getChild(i);
			ParFieldAccess fa = fieldArgs.getChild(i);

			gen.emitDup(); 															//arg0: the new object
			StringLiteral.push(gen, fa.getTypeAccess().type().fullName());			//arg1: recieve name
			StringLiteral.push(gen, fv.getFieldName()); 							//arg2: declaration name			
			StringLiteral.push(gen, fa.getFieldName()); 							//arg3: actual field name

			gen.emit(Bytecode.INVOKESTATIC, 1).add2(index);
		}
	}
}