aspect JavaDBNameCheck {
	
	eq L1ClassDecl.getOwnerClassAccess().nameType() = NameType.TYPE_NAME;
	eq L1GenericClassDecl.getOwnerClassAccess().nameType() = NameType.TYPE_NAME;

	//make geneic type visible for owner type
	eq L1GenericClassDecl.getOwnerClassAccess().lookupType(String name) {
		SimpleSet c = addTypeVariables(SimpleSet.emptySet, name);
		return !c.isEmpty() ? c : lookupType(name);
	}

	eq L2ClassDecl.getFieldParameter(int i).nameType() = NameType.TYPE_NAME;
	eq L2GenericClassDecl.getFieldParameter(int i).nameType() = NameType.TYPE_NAME;
	
	eq L2GenericClassDecl.getFieldParameter(int i).lookupType(String name) {
		SimpleSet c = addTypeVariables(SimpleSet.emptySet, name);
		return !c.isEmpty() ? c : lookupType(name);
	}

	eq parFieldArgAccess.getTypeAccess().nameType() = NameType.TYPE_NAME;

	syn lazy boolean VarAccess.isParField() = isQualified() && hostType().memberParFields(qualifier().type(), name()) != null;

	syn lazy boolean TypeDecl.isParFieldType() = false;
	eq L2ClassDecl.isParFieldType() = true;
	eq L2GenericClassDecl.isParFieldType() = true;
	eq RawClassDecl.isParFieldType() = original().isParFieldType();

	syn lazy List TypeDecl.getFieldPars() = new List();
	eq L2ClassDecl.getFieldPars() = getFieldParameters();
	eq L2GenericClassDecl.getFieldPars() = getFieldParameters();
	eq RawClassDecl.getFieldPars() = original().getFieldPars();
	eq ParClassDecl.getFieldPars() = original().getFieldPars();

	// refine VariableScope eq Expr.qualifiedLookupVariable(String name) {
	//  //      return VariableScope.Expr.qualifiedLookupVariable(name);
	//  if (type().accessibleFrom(hostType())) {
	//      //check if the field is field variable

	//      FieldVariable tmp = hostType().memberParFields(type(), name); //possibly hide the memberfields
	//      if (tmp == null)
	//          return keepAccessibleFields(type().memberFields(name));
	//      return SimpleSet.emptySet.add(tmp);
	//  }
	//  return SimpleSet.emptySet;
	// }

	refine Enums public void ClassInstanceExpr.nameCheck() {
		TypeDecl ty = type();
		if (type().isParFieldType()) {
			if (this instanceof ParFieldClassInstanceExpr == false) {
				error("class " + type().name() + " cannot be instantiated without any field argument");
			}
		} 
		refined();
	}

	refine NameCheck public void VarAccess.nameCheck() {
		if (isParField()) {
			//TODO: check subclass relation
		} else 
			refined();
	}

	// public void parFieldArgAccess.nameCheck() {
	// 	super.nameCheck();
	// 	SimpleSet decls = getTypeAccess().memberfields(getFieldName());
	// 	if (decls == null || decls.size() < 1) {
	// 		error(getFieldName() + " don't existed in class " + getTypeAccess().name());
	// 	} else if (decls.size() > 1) {
	// 		error("more than one field declare " + getFieldName() + " existed");
	// 	}
	// }

	public void ParFieldClassInstanceExpr.nameCheck() {
		super.nameCheck();
		List<FieldVariable> fieldPars = type().getFieldPars();
		List<parFieldArgAccess> fieldArgs = this.getFieldArguments();

		if (fieldPars.getNumChild() != fieldArgs.getNumChild()) {
			error("The number of field arguments to instantiated the class cannot match the declaration.");
		} 
		// else {
		// 	for (int i = 0; i < fieldArgs.getNumChild(); i++) {
		// 		FieldVariable fv = fieldPars.getChild(i);
		// 		parFieldArgAccess fa = fieldArgs.getChild(i);

		// 		TypeDecl ty = fv.getTargetTypeAccess().type();
		// 		SimpleSet decls = ty.memberFields(fa.getFieldName());
		// 		if (decls.size() == 0) {
		// 			error("");
		// 		} else if (decls.size() != 1)
		// 			error("unknow error");
		// 		}
		// }
	}


	public void parFieldArgAccess.nameCheck() {
		super.nameCheck();
		SimpleSet decls = getTypeAccess().type().memberFields(getFieldName());
		//TODO exclude statics
		if (decls.isEmpty()) {
      		error("no field named " + getFieldName() + " is accessible");
		}
	}

	rewrite PackageAccess {
    when(!duringSyntacticClassification() && hasPrevExpr() && prevExpr() instanceof VarAccess)
    to Access {
    	return new VarAccess(name(), start(), end());     	
    }
  }
}